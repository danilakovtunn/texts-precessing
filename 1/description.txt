Упражнение 1
В первом упражнении перечень условий задается в каждый скобке, начинающейся с ?= и ?!, кроме последнего, который задает состав пароля (символы из которых он состоит) и его длину
1) Пароль не должен содержать двух одинаковых символов подряд
(?!.*(?P<b2>[$^%@#&*!?\da-zA-Z])(?P=b2).*)
отрицание условия того, что в пароле встретится два символа подряд 
2) пароль должен содержать по крайней мере два различных специальных символа
(?=(.*(?P<b1>[%$^%@#&*!?]).*(?!(?P=b1))(?=[%$^%@#&*!?]).*[%$^%@#&*!?]))
Сначала находится и запоминается спецсивол, потом проверяется что существует спецсимвол не равный найденному
3) Пароль должен содержать по крайней мере одну цифру
(?=.*\d)
4) Пароль должен содержать по крайней мере один латинский символ в нижнем регистре
(?=.*[a-z])
5) Пароль должен содержать по крайней мере один латинский символ в верхнем регистре
(?=.*[A-Z])
6) пароль должен состоять из не менее чем восьми символов и тутже задается состав пароля
(?:[$^%@#&*!?\da-zA-Z]){8,}



Упражнение 2
В рамках этой подзадачи требуется разработать регулярное выражение, которым возможно проверить, может ли являться входная строка (целиком) корректной записью цвета в одном из трёх web форматов
1) Для начала создадим регулярные выражение вычисляющие все необходимые числа
NUM_100 = r'((?:[1-9])?[0-9]|100)'
NUM_256 = r'((?:[1-9])?[0-9]|1(?:[0-9]){2}|2[0-4][0-9]|25[0-5])'
NUM_360 = r'([0-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|360)'
2) Каждый из трех веб-форматов зададим отдельно и потом их объединим
2.1) RGB
RGB = fr'(rgb\(({NUM_256}|{NUM_100}%), *({NUM_256}|{NUM_100}%), *({NUM_256}|{NUM_100}%)\))'
2.2) HEX
HEX = r'#((?:[0-9a-fA-F]){6}|(?:[0-9a-fA-F]){3})'
2.3) HSL
HSL = fr'(hsl\({NUM_360}, *{NUM_100}%, *{NUM_100}%\))'
COLOR_REGEXP = fr'{RGB}|{HEX}|{HSL}'


Упражнение 3
Целью данной подзадачи является создание регулярного выражения, способного разбить строку, содержащую математическое выражение, на токены (элементарные части) и определить тип этих токенов
1) Зададим регулярные выражения для поиска перечень констант и функций для удобства
CONSTS = r'pi|e|sqrt2|ln2|ln10'
FUNCS = r'sin|cos|tg|ctg|tan|cot|sinh|cosh|th|cth|tanh|coth|ln|lg|log|exp|sqrt|cbrt|abs|sign'
2) Переменная
[a-z_](?:[a-zA-Z_0-9])* регулярное выражение для поиска всех переменных (consts и funcs тоже ищутся)
Поэтому зададим доп условие на то, что переменная это то, что начинается с CONSTS И FUNCS + какой-то символ
VARIABLE = fr'(?P<variable>(?!({CONSTS}|{FUNCS})(?![a-zA-Z_0-9]))[a-z_](?:[a-zA-Z_0-9])*)'
3) Константа числовая
NUMBER = r'(?P<number>
                (0|[1-9](?:[0-9])*) - неотрицательное число
                (?:\.(?:[0-9])*[1-9])? - возможная целая часть
           )'
4) Константы CONSTS
CONSTANT = fr'(?P<constant>{CONSTS})'
5) Названия функций FUNCS
FUNCTION = fr'(?P<function>{FUNCS})'
6) Перечень операторов
OPERATOR = r'(?P<operator>\^|\*|/|-|\+)'
7) Виды скобок
LEFT_PAR = r'(?P<left_parenthesis>\()'
RIGHT_PAR = r'(?P<right_parenthesis>\))'
8) Осталось расставить в правильном порядке. 
Следующий порядок дает наиболее высокую точность
EXPRESSION_REGEXP = fr'{VARIABLE}|{NUMBER}|{CONSTANT}|{FUNCTION}|{OPERATOR}|{LEFT_PAR}|{RIGHT_PAR}'


Упражнение 4
Требуется разработать регулярное выражение, способное определить, является ли входная строка (целиком) датой в одном из нескольких форматов.
1) Для удобства возможная длина месяцев
NUM_28 = r'(0?[1-9]|1[0-9]|2[0-8])'
NUM_30 = r'(0?[1-9]|[1-2][0-9]|30)'
NUM_31 = fr'({NUM_30}|31)'
2) Номера месяцев в который X (NUM_12_X) дней
NUM_12_31 = r'(0?[13578]|1[02])' #1,3,5,7,8,10,12
NUM_12_30 = r'(0?[469]|11)' #4,6,9,11
NUM_12_28 = r'(0?2)'
3) неотрицательный год
YEAR = r'([1-9]\d*|0)'
4) название месяцев в которых X дней rus
MONTH_RUS_28 = r'(февраля)'
MONTH_RUS_31 = r'(января|марта|мая|июля|августа|октября|ноября|декабря)'
MONTH_RUS_30 = r'(апреля|июня|сентября|ноября)'
5) тоже что и 4, только eng
MONTH_ENG_28 = r'(February|Feb)'
MONTH_ENG_31 = r'(January|Jan|March|Mar|May|July|Jul|August|Aug|October|Oct|December|Dec)'
MONTH_ENG_30 = r'(April|Apr|June|Jun|September|Sep|November|Nov)'
6) Как можно заметить всего 3 вида формата дат
6.1)
обратим внимание на то что месяц это либо разделитель-число-<тот же разделитель> или пробел-название месяца-пробел
DDMMYYYY = fr'{NUM_28}((?P<del1>[/.-]){NUM_12_28}(?P=del1)| {MONTH_RUS_28} ){YEAR}| - февраль
              {NUM_30}((?P<del2>[/.-]){NUM_12_30}(?P=del2)| {MONTH_RUS_30} ){YEAR}| - месяцы, в которых 30 дней
              {NUM_31}((?P<del3>[/.-]){NUM_12_31}(?P=del3)| {MONTH_RUS_31} ){YEAR}'
6.2)
обратим внимание на то что месяц это либо разделитель-число-<тот же разделитель> или запятая-пробел-название месяца-пробел
YYYYMMDD = fr'{YEAR}((?P<sep1>[/.-]){NUM_12_28}(?P=sep1)|, {MONTH_ENG_28} ){NUM_28}|
              {YEAR}((?P<sep2>[/.-]){NUM_12_30}(?P=sep2)|, {MONTH_ENG_30} ){NUM_30}|
              {YEAR}((?P<sep3>[/.-]){NUM_12_31}(?P=sep3)|, {MONTH_ENG_31} ){NUM_31}'
6.3)
просто три различных случая в зависимости от месяца
MMDDYYYY = fr'{MONTH_ENG_28} {NUM_28}, {YEAR}|
              {MONTH_ENG_30} {NUM_30}, {YEAR}|
              {MONTH_ENG_31} {NUM_31}, {YEAR}'
7) запишем каждое выражение через |
DATES_REGEXP = fr'{DDMMYYYY}|{YYYYMMDD}|{MMDDYYYY}'
